import { govnSvcVersion as gsv } from "./deps.ts";
import * as interp from "./interpolate.ts";

export type TextValue = string;
export interface TextValueSupplier {
  (...args: string[]): string;
}

export interface SchemaNameSupplier {
  prefix: TextValue;
  lifecycle: TextValue;
  assurance: TextValue;
  experimental: TextValue;
  stateless: TextValueSupplier;
}

export interface DeploymentLifecycleFunctionCriterionSupplier {
  prefix: TextValue;
  construct: TextValueSupplier;
  destroy: TextValueSupplier;
}

export interface FunctionNameSupplier {
  prefix: TextValue;
  stateless: TextValueSupplier;
  administrative: TextValueSupplier;
  destructive: TextValueSupplier;
  deploy: DeploymentLifecycleFunctionCriterionSupplier;
}

export interface InterpolationContext {
  readonly schemaName: SchemaNameSupplier;
  readonly functionName: FunctionNameSupplier;
}

export function typicalInterpolationContext(): InterpolationContext {
  const ic: InterpolationContext = {
    schemaName: {
      prefix: "dcp_",
      lifecycle: "dcp_lifecyle",
      assurance: "dcp_assurance_engineering",
      experimental: "dcp_experimental",
      stateless: (name: string) => {
        return `${ic.schemaName.prefix}${name}`;
      },
    },
    functionName: {
      prefix: "dcp_",
      stateless: (name: string) => {
        return `${ic.functionName.prefix}${name}`;
      },
      administrative: (name: string) => {
        return `${ic.schemaName.lifecycle}.${ic.functionName.prefix}${name}`;
      },
      destructive: (name: string) => {
        return `${ic.schemaName.lifecycle}.${ic.functionName.prefix}${name}`;
      },
      deploy: {
        prefix: "dcp_lc_deploy_",
        construct: (name: string) => {
          return `${ic.schemaName.lifecycle}.${ic.functionName.deploy.prefix}construct_${name}`;
        },
        destroy: (name: string) => {
          return `${ic.schemaName.lifecycle}.${ic.functionName.deploy.prefix}destroy_${name}`;
        },
      },
    },
  };
  return ic;
}

export async function typicalProvenance(
  importMetaURL: string,
  moduleIdentity?: string,
): Promise<interp.TemplateProvenance> {
  if (!moduleIdentity) {
    // get the name of the module without the path
    moduleIdentity = importMetaURL.split("/").pop();
  }
  return {
    importMetaURL,
    version: await gsv.determineVersionFromRepoTag(
      importMetaURL,
      { repoIdentity: moduleIdentity },
    ),
  };
}

export async function typicalState<C extends InterpolationContext>(
  engine: interp.InterpolationEngine<C>,
  importMetaURL: string,
  moduleIdentity?: string,
): Promise<interp.InterpolationState<interp.TemplateProvenance>> {
  const provenance = await typicalProvenance(importMetaURL, moduleIdentity);
  return {
    provenance: provenance,
    execID: engine.prepareIdentity(provenance),
    frontMatter: () => {
      return `
      -- Code generated by PgDCP ${engine.version}. DO NOT EDIT.
      -- assembled: ${Deno.hostname()} (${Deno.build.os}, ${Deno.build.arch})
      -- source: ${provenance.importMetaURL}
      -- version: ${provenance.version}
      `;
    },
  };
}
