interpolateShebangContent := "../interpolate-shebang-content.pl"
supplyRecipeJustFile := "../recipe-suppliers.justfile"

_pg-dcp-recipe +ARGS:
    @just -f {{supplyRecipeJustFile}} {{ARGS}}

# Generate psql SQL snippet to create a named variant's objects
psql-construct variant defaultCtx defaultPath:
    #!/usr/bin/env {{interpolateShebangContent}}
    CREATE EXTENSION if not exists ltree;

    CREATE TABLE {{variant}}(
        id integer GENERATED BY DEFAULT AS IDENTITY,
        nature ltree NOT NULL,
        context ltree NOT NULL,
        path ltree NOT NULL,
        name text NOT NULL,
        description text,
        sym_link_{{variant}}_id integer REFERENCES {{variant}}(id),
        active boolean NOT NULL DEFAULT TRUE,
        created_at timestamp with time zone NOT NULL default current_date,
        updated_at timestamp with time zone,
        deleted_at timestamp with time zone,
        CONSTRAINT {{variant}}_pk UNIQUE(id),
        CONSTRAINT {{variant}}_unq_row UNIQUE(context, path, name)
    );
    CREATE INDEX {{variant}}_nature_idx ON {{variant}} USING gist (nature);
    CREATE INDEX {{variant}}_context_idx ON {{variant}} USING gist (context);
    CREATE INDEX {{variant}}_path_idx ON {{variant}} USING gist (path);
    CREATE INDEX {{variant}}_name_idx ON {{variant}} (path);

    CREATE TABLE {{variant}}_sensitivity(
        id integer GENERATED BY DEFAULT AS IDENTITY,
        {{variant}}_id integer NOT NULL REFERENCES {{variant}} (id),
        sensitivity ltree NOT NULL,
        active boolean NOT NULL DEFAULT TRUE
    );
    CREATE INDEX {{variant}}_sensitivity_idx ON {{variant}}_sensitivity USING gist (sensitivity);

    CREATE TABLE {{variant}}_value_text(
        id integer GENERATED BY DEFAULT AS IDENTITY,
        {{variant}}_id integer NOT NULL REFERENCES {{variant}}(id),
        value text not null
    );

    CREATE TABLE {{variant}}_value_json(
        id integer GENERATED BY DEFAULT AS IDENTITY,
        {{variant}}_id integer NOT NULL REFERENCES {{variant}}(id),
        value JSONB not null
    );

    CREATE TABLE {{variant}}_value_xml(
        id integer GENERATED BY DEFAULT AS IDENTITY,
        {{variant}}_id integer NOT NULL REFERENCES {{variant}}(id),
        value XML not null
    );

    CREATE OR REPLACE VIEW {{variant}}_text AS
        select {{variant}}.id as {{variant}}_id,
               nature, value, context, path, name, description,
               {{variant}}_value_text.id as value_id
          from {{variant}}, {{variant}}_value_text
         where {{variant}}.id = {{variant}}_value_text.{{variant}}_id 
           and active = true;

    create or replace function insert_{{variant}}_text() returns trigger as $$
    declare
        {{variant}}Id integer;
    begin
        insert into {{variant}} (nature, context, path, name, description) select 
            (CASE WHEN (NEW.nature IS NULL) THEN 'text' ELSE NEW.nature END),
            (CASE WHEN (NEW.context IS NULL) THEN '{{defaultCtx}}' ELSE NEW.context END),
            (CASE WHEN (NEW.path IS NULL) THEN '{{defaultPath}}' ELSE NEW.path END),
            NEW.name,
            NEW.description 
            returning id into {{variant}}Id;
        insert into {{variant}}_value_text ({{variant}}_id, value) select {{variant}}Id, NEW.value;
        return NEW;
    end;
    $$ language plpgsql;

    create trigger insert_{{variant}}_text_trigger
    instead of insert on {{variant}}_text
    for each row execute function insert_{{variant}}_text();

    CREATE OR REPLACE VIEW {{variant}}_json AS
        select {{variant}}.id as {{variant}}_id,
               nature, value, context, path, name, description,
               {{variant}}_value_json.id as value_id
          from {{variant}}, {{variant}}_value_json
         where {{variant}}.id = {{variant}}_value_json.{{variant}}_id 
           and active = true;

    create or replace function insert_{{variant}}_json() returns trigger as $$
    declare
        {{variant}}Id integer;
    begin
        insert into {{variant}} (nature, context, path, name, description) select 
            (CASE WHEN (NEW.nature IS NULL) THEN 'json' ELSE NEW.nature END),
            (CASE WHEN (NEW.context IS NULL) THEN '{{defaultCtx}}' ELSE NEW.context END),
            (CASE WHEN (NEW.path IS NULL) THEN '{{defaultPath}}' ELSE NEW.path END),
            NEW.name,
            NEW.description 
            returning id into {{variant}}Id;
        insert into {{variant}}_value_json ({{variant}}_id, value) select {{variant}}Id, NEW.value;
        return NEW;
    end;
    $$ language plpgsql;

    create trigger insert_{{variant}}_json_trigger
    instead of insert on {{variant}}_json
    for each row execute function insert_{{variant}}_json();

    CREATE OR REPLACE VIEW {{variant}}_xml AS
        select {{variant}}.id as {{variant}}_id,
               nature, value, context, path, name, description,
               {{variant}}_value_xml.id as value_id
          from {{variant}}, {{variant}}_value_xml
         where {{variant}}.id = {{variant}}_value_xml.{{variant}}_id 
           and active = true;

    create or replace function insert_{{variant}}_xml() returns trigger as $$
    declare
        {{variant}}Id integer;
    begin
        insert into {{variant}} (nature, context, path, name, description) select 
            (CASE WHEN (NEW.nature IS NULL) THEN 'xml' ELSE NEW.nature END),
            (CASE WHEN (NEW.context IS NULL) THEN '{{defaultCtx}}' ELSE NEW.context END),
            (CASE WHEN (NEW.path IS NULL) THEN '{{defaultPath}}' ELSE NEW.path END),
            NEW.name,
            NEW.description 
            returning id into {{variant}}Id;
        insert into {{variant}}_value_xml ({{variant}}_id, value) select {{variant}}Id, NEW.value;
        return NEW;
    end;
    $$ language plpgsql;

    create trigger insert_{{variant}}_xml_trigger
    instead of insert on {{variant}}_xml
    for each row execute function insert_{{variant}}_xml();

# Generate psql SQL snippet to drop all named variant objects
psql-destroy variant:
    #!/usr/bin/env {{interpolateShebangContent}}
    drop table if exists {{variant}}_sensitivity;
    drop table if exists {{variant}}_value_json;
    drop table if exists {{variant}}_value_text;
    drop table if exists {{variant}};
