import * as mod from "../mod.ts";
import * as schemas from "../schemas.ts";

export const affinityGroup = new schemas.TypicalAffinityGroup(
  "asset",
);

export function SQL(
  ctx: mod.DcpInterpolationContext,
  options?: mod.InterpolationContextStateOptions,
): mod.DcpInterpolationResult {
  const state = ctx.prepareState(
    ctx.prepareTsModuleExecution(import.meta.url),
    {
      schema: schemas.lib,
      affinityGroup,
      ...options,
      extensions: [schemas.extensions.ltreeExtn],
    },
  );
  const { qualifiedReference: sqr } = state.schema;
  const { qualifiedReference: exqr } = schemas.extensions;
  const { lcFunctions: fn } = state.affinityGroup;

  // deno-fmt-ignore
  return mod.SQL(ctx, state)`
    CREATE OR REPLACE PROCEDURE ${fn.constructStorage(state).qName}() AS $$
    BEGIN
      CREATE DOMAIN ${sqr("asset_state")} as ${exqr("ltree")};
      CREATE OR REPLACE FUNCTION ${sqr("asset_state_active")}() RETURNS ${sqr("asset_state")} LANGUAGE sql IMMUTABLE PARALLEL SAFE AS 'SELECT ''active''::${sqr("asset_state")}';
      CREATE OR REPLACE FUNCTION ${sqr("asset_state_deleted")}(pk bigint) RETURNS ${sqr("asset_state")} LANGUAGE sql IMMUTABLE PARALLEL SAFE AS 'SELECT (''deleted.'' || pk::text)::${sqr("asset_state")}';
      -- when a row is deleted, state will be set to 'deleted.X' where X is the primary key of record being deleted

      -- history, metrics, telemetry, and other data is stored in observability column in each table

      CREATE TABLE ${sqr("asset_provenance")}(
        asset_provenance_id bigint GENERATED BY DEFAULT AS IDENTITY,
        context ${exqr("ltree")},
        name text NOT NULL,
        uri text NOT NULL,
        nature ${exqr("ltree")},
        meta jsonb,
        observability jsonb,
        state ${sqr("asset_state")} NOT NULL default ${sqr("asset_state_active")}(),
        created_at timestamptz NOT NULL default current_timestamp,
        created_by name NOT NULL default current_user,
        CONSTRAINT asset_provenance_pk UNIQUE(asset_provenance_id),
        CONSTRAINT asset_provenance_unq_row UNIQUE(context, name, uri, state)
      );
      CREATE INDEX asset_provenance_context_idx ON ${sqr("asset_provenance")} USING gist (context);
      CREATE INDEX asset_provenance_name_idx ON ${sqr("asset_provenance")} (name);
      CREATE INDEX asset_provenance_uri_idx ON ${sqr("asset_provenance")} (uri);
      CREATE INDEX asset_provenance_nature_idx ON ${sqr("asset_provenance")} USING gist (nature);
      CREATE INDEX asset_provenance_state_idx ON ${sqr("asset_provenance")} USING gist (state);
      CREATE INDEX asset_provenance_meta_idx ON ${sqr("asset_provenance")} USING gin (meta);
      CREATE INDEX asset_provenance_observability_idx ON ${sqr("asset_provenance")} USING gin (observability);
     
      -- reference to an unrevisioned asset, but not the asset itself
      CREATE TABLE ${sqr("asset_reference")}(
        asset_reference_id bigint GENERATED BY DEFAULT AS IDENTITY,
        asset_provenance_id bigint NOT NULL REFERENCES ${sqr("asset_provenance")}(asset_provenance_id), 
        name text NOT NULL,
        uri text NOT NULL,
        nature ${exqr("ltree")},
        meta jsonb,
        observability jsonb,
        state ${sqr("asset_state")} NOT NULL default ${sqr("asset_state_active")}(),
        created_at timestamptz NOT NULL default current_timestamp,
        created_by name NOT NULL default current_user,
        CONSTRAINT asset_reference_pk UNIQUE(asset_reference_id),
        CONSTRAINT asset_reference_unq_row UNIQUE(asset_provenance_id, name, uri, state)
      );
      CREATE INDEX asset_reference_id_idx ON ${sqr("asset_reference")} (asset_provenance_id);
      CREATE INDEX asset_reference_nature_idx ON ${sqr("asset_reference")} USING gist (nature);
      CREATE INDEX asset_reference_name_idx ON ${sqr("asset_reference")} (name);
      CREATE INDEX asset_reference_uri_idx ON ${sqr("asset_reference")} (uri);
      CREATE INDEX asset_reference_state_idx ON ${sqr("asset_reference")} USING gist (state);
      CREATE INDEX asset_reference_meta_idx ON ${sqr("asset_reference")} USING gin (meta);
      CREATE INDEX asset_reference_observability_idx ON ${sqr("asset_reference")} USING gin (observability);

      -- actual asset, with original untransformed (often base64 encoded) object
      CREATE TABLE ${sqr("asset")}(
        asset_id bigint GENERATED BY DEFAULT AS IDENTITY,
        asset_provenance_id bigint NOT NULL REFERENCES ${sqr("asset_provenance")}(asset_provenance_id),
        name text NOT NULL,
        uri text NOT NULL,
        nature ${exqr("ltree")} NOT NULL, -- physical nature of content, should be null or 'encoded.base64', 'text', 'json', 'yaml', etc.
        content_hash text NOT NULL,
        asset_revision_hash text NOT NULL,
        content text NOT NULL, -- could be base64-encoded arbitrary content or actual text, depending on nature
        content_bytes bigint NOT NULL, -- bytes in the actual content (unencoded base64 if encoded)
        content_mime_type text,
        meta jsonb,
        observability jsonb,
        state ${sqr("asset_state")} NOT NULL default ${sqr("asset_state_active")}(),
        created_at timestamptz NOT NULL default current_timestamp,
        created_by name NOT NULL default current_user,
        CONSTRAINT asset_pk UNIQUE(asset_id),
        CONSTRAINT asset_unq_row UNIQUE(asset_provenance_id, name, uri, content_hash, asset_revision_hash, state)
      );
      CREATE INDEX asset_provenance_id_idx ON ${sqr("asset")} (asset_provenance_id);
      CREATE INDEX asset_nature_idx ON ${sqr("asset")} USING gist (nature);
      CREATE INDEX asset_name_idx ON ${sqr("asset")} (name);
      CREATE INDEX asset_uri_idx ON ${sqr("asset")} (uri);
      CREATE INDEX asset_hash_idx ON ${sqr("asset")} (content_hash);
      CREATE INDEX asset_state_idx ON ${sqr("asset")} USING gist (state);
      CREATE INDEX asset_meta_idx ON ${sqr("asset")} USING gin (meta);
      CREATE INDEX asset_observability_idx ON ${sqr("asset")} USING gin (observability);

      -- actual asset, transformed content to text format (1:1 relationship to asset)
      CREATE TABLE ${sqr("asset_content_text")}(
        asset_content_text_id bigint GENERATED BY DEFAULT AS IDENTITY,
        asset_id bigint NOT NULL REFERENCES ${sqr("asset")}(asset_id), 
        content text NOT NULL,
        content_mime_type text,
        nature ${exqr("ltree")}, -- optional, logical, nature, after transformation from original asset
        observability jsonb,
        meta jsonb,
        state ${sqr("asset_state")} NOT NULL default ${sqr("asset_state_active")}(),
        created_at timestamptz NOT NULL default current_timestamp,
        created_by name NOT NULL default current_user,
        CONSTRAINT asset_content_text_pk UNIQUE(asset_content_text_id),
        CONSTRAINT asset_content_text_unq_row UNIQUE(asset_id, state)
      );      
      CREATE INDEX asset_content_text_asset_id_idx ON ${sqr("asset_content_text")} (asset_id);
      CREATE INDEX asset_content_text_nature_idx ON ${sqr("asset_content_text")} USING gist (nature);
      CREATE INDEX asset_content_text_state_idx ON ${sqr("asset_content_text")} USING gist (state);
      CREATE INDEX asset_content_text_meta_idx ON ${sqr("asset_content_text")} USING gin (meta);
      CREATE INDEX asset_content_text_observability_idx ON ${sqr("asset_content_text")} USING gin (observability);

      -- actual asset, transformed content to JSON format (1:1 relationship to asset)
      CREATE TABLE ${sqr("asset_content_json")}(
        asset_content_json_id bigint GENERATED BY DEFAULT AS IDENTITY,
        asset_id bigint NOT NULL REFERENCES ${sqr("asset")}(asset_id), 
        content jsonb NOT NULL,
        content_mime_type text,
        nature ${exqr("ltree")}, -- optional, logical, nature, after transformation from original asset
        observability jsonb,
        meta jsonb,
        state ${sqr("asset_state")} NOT NULL default ${sqr("asset_state_active")}(),
        created_at timestamptz NOT NULL default current_timestamp,
        created_by name NOT NULL default current_user,
        CONSTRAINT asset_content_json_pk UNIQUE(asset_content_json_id),
        CONSTRAINT asset_content_json_unq_row UNIQUE(asset_id, state)
      );      
      CREATE INDEX asset_content_json_asset_id_idx ON ${sqr("asset_content_json")} (asset_id);
      CREATE INDEX asset_content_json_nature_idx ON ${sqr("asset_content_json")} USING gist (nature);
      CREATE INDEX asset_content_json_state_idx ON ${sqr("asset_content_json")} USING gist (state);
      CREATE INDEX asset_content_json_meta_idx ON ${sqr("asset_content_json")} USING gin (meta);
      CREATE INDEX asset_content_json_observability_idx ON ${sqr("asset_content_json")} USING gin (observability);

      -- actual asset, transformed content to bytea binary representation (1:1 relationship to asset)
      CREATE TABLE ${sqr("asset_content_bytea")}(
        asset_content_bytea_id bigint GENERATED BY DEFAULT AS IDENTITY,
        asset_id bigint NOT NULL REFERENCES ${sqr("asset")}(asset_id), 
        content bytea NOT NULL,
        nature ${exqr("ltree")}, -- optional, logical, nature, after transformation from original asset
        content_mime_type text,
        meta jsonb,
        observability jsonb,
        state ${sqr("asset_state")} NOT NULL default ${sqr("asset_state_active")}(),
        created_at timestamptz NOT NULL default current_timestamp,
        created_by name NOT NULL default current_user,
        CONSTRAINT asset_content_bytea_pk UNIQUE(asset_content_bytea_id),
        CONSTRAINT asset_content_bytea_unq_row UNIQUE(asset_id, state)
      );      
      CREATE INDEX asset_content_bytea_asset_id_idx ON ${sqr("asset_content_bytea")} (asset_id);
      CREATE INDEX asset_content_bytea_nature_idx ON ${sqr("asset_content_bytea")} USING gist (nature);
      CREATE INDEX asset_content_bytea_state_idx ON ${sqr("asset_content_bytea")} USING gist (state);
      CREATE INDEX asset_content_bytea_meta_idx ON ${sqr("asset_content_bytea")} USING gin (meta);
      CREATE INDEX asset_content_bytea_observability_idx ON ${sqr("asset_content_bytea")} USING gin (observability);

      -- a document is searchable text for an asset (1:1 relationship to asset + asset_content_*)
      CREATE TABLE ${sqr("asset_content_document")}(
        asset_content_document_id bigint GENERATED BY DEFAULT AS IDENTITY,
        asset_id bigint NOT NULL REFERENCES ${sqr("asset")}(asset_id),
        nature ${exqr("ltree")} NOT NULL, -- should be 'asset' or 'asset.component.*', etc.
        content_text_id bigint REFERENCES ${sqr("asset_content_text")}(asset_content_text_id),
        content_json_id bigint REFERENCES ${sqr("asset_content_json")}(asset_content_json_id),
        content_bytea_id bigint REFERENCES ${sqr("asset_content_bytea")}(asset_content_bytea_id),
        content_tsv tsvector NOT NULL,
        meta jsonb,
        observability jsonb,
        state ${sqr("asset_state")} NOT NULL default ${sqr("asset_state_active")}(),
        created_at timestamptz NOT NULL default current_timestamp,
        created_by name NOT NULL default current_user,
        CONSTRAINT asset_content_document_content_id_chk check (content_text_id is not null or content_json_id is not null or content_bytea_id is not null),
        CONSTRAINT asset_content_document_pk UNIQUE(asset_content_document_id),
        CONSTRAINT asset_content_document_unq_row UNIQUE(asset_id, nature, state)
      );    
      CREATE INDEX asset_content_document_asset_id_idx ON ${sqr("asset_content_document")} (asset_id);
      CREATE INDEX asset_content_document_nature_idx ON ${sqr("asset_content_document")} USING gist (nature);
      CREATE INDEX asset_content_document_state_idx ON ${sqr("asset_content_document")} USING gist (state);
      CREATE INDEX asset_content_document_meta_idx ON ${sqr("asset_content_document")} USING gin (meta);
      CREATE INDEX asset_content_document_observability_idx ON ${sqr("asset_content_document")} USING gin (observability);

      CREATE TABLE ${sqr("asset_revision")}(
        revision_id bigint GENERATED BY DEFAULT AS IDENTITY,
        asset_provenance_id bigint NOT NULL REFERENCES ${sqr("asset_provenance")}(asset_provenance_id),
        asset_id bigint NOT NULL REFERENCES ${sqr("asset")}(asset_id), 
        revision_hash text NOT NULL,
        revision_nature ${exqr("ltree")},
        revision_message text,
        author_name text,
        author_email text,
        committer_name text,
        committer_email text,
        committed_at timestamptz,
        authored_at timestamptz,
        meta jsonb,
        observability jsonb,
        state ${sqr("asset_state")} NOT NULL default ${sqr("asset_state_active")}(),
        created_at timestamptz NOT NULL default current_timestamp,
        created_by name NOT NULL default current_user,
        CONSTRAINT asset_revision_pk UNIQUE(revision_id),
        CONSTRAINT asset_revision_unq_row UNIQUE(asset_provenance_id, asset_id, revision_hash, state)
      );
      CREATE INDEX asset_revision_nature_idx ON ${sqr("asset_revision")} USING gist (revision_nature);
      CREATE INDEX asset_revision_hash_idx ON ${sqr("asset_revision")} (revision_hash);
      CREATE INDEX asset_revision_state_idx ON ${sqr("asset_revision")} USING gist (state);
      CREATE INDEX asset_revision_meta_idx ON ${sqr("asset_revision")} USING gin (meta);
      CREATE INDEX asset_revision_observability_idx ON ${sqr("asset_revision")} USING gin (observability);
    END;
    $$ LANGUAGE PLPGSQL;

    CREATE OR REPLACE PROCEDURE ${fn.constructIdempotent(state).qName}() AS $$
    BEGIN
      ${state.setSearchPathSql()};
    END;
    $$ LANGUAGE PLPGSQL;

    CREATE OR REPLACE PROCEDURE ${fn.destroyIdempotent(state).qName}() AS $$
    BEGIN
        DROP FUNCTION IF EXISTS ${fn.unitTest(state).qName}();        
        DROP TABLE IF EXISTS ${sqr("asset_provenance")} CASCADE;        
        DROP TABLE IF EXISTS ${sqr("asset_reference")} CASCADE;        
        DROP TABLE IF EXISTS ${sqr("asset")} CASCADE;        
        DROP TABLE IF EXISTS ${sqr("asset_revision")} CASCADE;        
    END;
    $$ LANGUAGE PLPGSQL;

    CREATE OR REPLACE FUNCTION ${
    fn.unitTest(state).qName
  }() RETURNS SETOF TEXT AS $$
    BEGIN 
        RETURN NEXT has_table('${state.schema.name}', 'asset_provenance');
        RETURN NEXT has_table('${state.schema.name}', 'asset_reference');
        RETURN NEXT has_table('${state.schema.name}', 'asset');
        RETURN NEXT has_table('${state.schema.name}', 'asset_revision');
    END;
    $$ LANGUAGE plpgsql;`;
}
