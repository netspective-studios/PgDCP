import * as mod from "../mod.ts";
import * as schemas from "../schemas.ts";

export const affinityGroup = new schemas.TypicalAffinityGroup(
  "remote_asset",
);

export function SQL(
  ctx: mod.DcpInterpolationContext,
  options?: mod.InterpolationContextStateOptions,
): mod.DcpInterpolationResult {
  const state = ctx.prepareState(
    ctx.prepareTsModuleExecution(import.meta.url),
    {
      schema: schemas.lib,
      affinityGroup,
      ...options,
      extensions: [schemas.extensions.ltreeExtn],
    },
  );
  const { qualifiedReference: sqr } = state.schema;
  const { qualifiedReference: exqr } = schemas.extensions;
  const { lcFunctions: fn } = state.affinityGroup;

  // deno-fmt-ignore
  return mod.SQL(ctx, state)`
    CREATE OR REPLACE PROCEDURE ${fn.constructStorage(state).qName}() AS $$
    BEGIN
      CREATE TABLE ${sqr("remote_asset_provenance")}(
        rap_id integer GENERATED BY DEFAULT AS IDENTITY,
        rap_name text NOT NULL,
        rap_uri text NOT NULL,
        rap_nature ${exqr("ltree")},
        rap_meta jsonb,
        created_at timestamptz NOT NULL default current_timestamp,
        created_by name NOT NULL default current_user,
        updated_at timestamptz,
        updated_by name,
        deleted_at timestamptz,
        deleted_by name,
        CONSTRAINT remote_asset_provenance_pk UNIQUE(rap_id),
        CONSTRAINT remote_asset_provenance_unq_row UNIQUE(rap_name, rap_uri)
      );
      CREATE INDEX remote_asset_provenance_nature_idx ON ${sqr("remote_asset_provenance")} USING gist (rap_nature);
     
      -- reference to an asset, but not the asset itself
      CREATE TABLE ${sqr("remote_asset_reference")}(
        asset_ref_id integer GENERATED BY DEFAULT AS IDENTITY,
        rap_id integer NOT NULL REFERENCES ${sqr("remote_asset_provenance")}(rap_id), 
        asset_name text NOT NULL,
        asset_uri text NOT NULL,
        asset_nature ${exqr("ltree")},
        asset_ref_meta jsonb,
        created_at timestamptz NOT NULL default current_timestamp,
        created_by name NOT NULL default current_user,
        updated_at timestamptz,
        updated_by name,
        deleted_at timestamptz,
        deleted_by name,
        CONSTRAINT remote_asset_reference_pk UNIQUE(asset_ref_id),
        CONSTRAINT remote_asset_reference_unq_row UNIQUE(rap_id, asset_name, asset_uri)
      );
      CREATE INDEX remote_asset_reference_nature_idx ON ${sqr("remote_asset_reference")} USING gist (asset_nature);
      CREATE INDEX remote_asset_reference_name_idx ON ${sqr("remote_asset_reference")} (asset_name);
      CREATE INDEX remote_asset_reference_path_idx ON ${sqr("remote_asset_reference")} (asset_uri);

      -- actual asset, with content
      CREATE TABLE ${sqr("remote_asset")}(
        asset_id integer GENERATED BY DEFAULT AS IDENTITY,
        rap_id integer NOT NULL REFERENCES ${sqr("remote_asset_provenance")}(rap_id),
        asset_name text NOT NULL,
        asset_uri text NOT NULL,
        asset_nature ${exqr("ltree")}, -- should be null or 'text', 'encoded.base64', etc.
        asset_hash text NOT NULL,
        asset_revision_hash text,
        asset_content text NOT NULL,
        asset_bytes integer NOT NULL,
        asset_meta jsonb,
        created_at timestamptz NOT NULL default current_timestamp,
        created_by name NOT NULL default current_user,
        updated_at timestamptz,
        updated_by name,
        deleted_at timestamptz,
        deleted_by name,
        CONSTRAINT remote_asset_pk UNIQUE(asset_id),
        CONSTRAINT remote_asset_unq_row UNIQUE(rap_id, asset_name, asset_uri, asset_hash, asset_revision_hash)
      );
      CREATE INDEX remote_asset_nature_idx ON ${sqr("remote_asset")} USING gist (asset_nature);
      CREATE INDEX remote_asset_name_idx ON ${sqr("remote_asset")} (asset_name);
      CREATE INDEX remote_asset_path_idx ON ${sqr("remote_asset")} (asset_uri);
      CREATE INDEX remote_asset_hash_idx ON ${sqr("remote_asset")} (asset_hash);

      CREATE TABLE ${sqr("remote_asset_revision")}(
        revision_id integer GENERATED BY DEFAULT AS IDENTITY,
        rap_id integer NOT NULL REFERENCES ${sqr("remote_asset_provenance")}(rap_id),
        asset_id integer NOT NULL REFERENCES ${sqr("remote_asset")}(asset_id), 
        revision_hash text NOT NULL,
        revision_nature ${exqr("ltree")},
        revision_message text,
        author_name text,
        author_email text,
        committer_name text,
        committer_email text,
        committed_at timestamptz,
        authored_at timestamptz,
        revision_meta jsonb,
        created_at timestamptz NOT NULL default current_timestamp,
        created_by name NOT NULL default current_user,
        updated_at timestamptz,
        updated_by name,
        deleted_at timestamptz,
        deleted_by name,
        CONSTRAINT remote_asset_revision_pk UNIQUE(revision_id),
        CONSTRAINT remote_asset_revision_unq_row UNIQUE(rap_id, asset_id, revision_hash)
      );
      CREATE INDEX remote_asset_revision_nature_idx ON ${sqr("remote_asset_revision")} USING gist (revision_nature);
      CREATE INDEX remote_asset_revision_hash_idx ON ${sqr("remote_asset_revision")} (revision_hash);
    END;
    $$ LANGUAGE PLPGSQL;

    CREATE OR REPLACE PROCEDURE ${fn.constructIdempotent(state).qName}() AS $$
    BEGIN
      ${state.setSearchPathSql()};
    END;
    $$ LANGUAGE PLPGSQL;

    CREATE OR REPLACE PROCEDURE ${fn.destroyIdempotent(state).qName}() AS $$
    BEGIN
        DROP FUNCTION IF EXISTS ${fn.unitTest(state).qName}();        
        DROP TABLE IF EXISTS ${sqr("remote_asset_provenance")} CASCADE;        
        DROP TABLE IF EXISTS ${sqr("remote_asset_reference")} CASCADE;        
        DROP TABLE IF EXISTS ${sqr("remote_asset")} CASCADE;        
        DROP TABLE IF EXISTS ${sqr("remote_asset_revision")} CASCADE;        
    END;
    $$ LANGUAGE PLPGSQL;

    CREATE OR REPLACE FUNCTION ${
    fn.unitTest(state).qName
  }() RETURNS SETOF TEXT AS $$
    BEGIN 
        RETURN NEXT has_table('${state.schema.name}', 'remote_asset_provenance');
        RETURN NEXT has_table('${state.schema.name}', 'remote_asset_reference');
        RETURN NEXT has_table('${state.schema.name}', 'remote_asset');
        RETURN NEXT has_table('${state.schema.name}', 'remote_asset_revision');
    END;
    $$ LANGUAGE plpgsql;`;
}
