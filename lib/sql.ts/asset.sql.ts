import * as mod from "../mod.ts";
import * as schemas from "../schemas.ts";

export const affinityGroup = new schemas.TypicalAffinityGroup(
  "asset",
);

export function SQL(
  ctx: mod.DcpInterpolationContext,
  options?: mod.InterpolationContextStateOptions,
): mod.DcpInterpolationResult {
  const state = ctx.prepareState(
    ctx.prepareTsModuleExecution(import.meta.url),
    {
      schema: schemas.lib,
      affinityGroup,
      ...options,
      extensions: [schemas.extensions.ltreeExtn],
    },
  );
  const { qualifiedReference: sqr } = state.schema;
  const { qualifiedReference: exqr } = schemas.extensions;
  const { lcFunctions: fn } = state.affinityGroup;

  // deno-fmt-ignore
  return mod.SQL(ctx, state)`
    CREATE OR REPLACE PROCEDURE ${fn.constructStorage(state).qName}() AS $$
    BEGIN
      CREATE DOMAIN ${sqr("asset_state")} as ${exqr("ltree")};
      CREATE OR REPLACE FUNCTION ${sqr("asset_state_active")}() RETURNS ${sqr("asset_state")} LANGUAGE sql IMMUTABLE PARALLEL SAFE AS 'SELECT ''active''::${sqr("asset_state")}';
      CREATE OR REPLACE FUNCTION ${sqr("asset_state_deleted")}(pk bigint) RETURNS ${sqr("asset_state")} LANGUAGE sql IMMUTABLE PARALLEL SAFE AS 'SELECT (''deleted.'' || pk::text)::${sqr("asset_state")}';
      -- when a row is deleted, state will be set to 'deleted.X' where X is the primary key of record being deleted

      -- history, metrics, telemetry, and other data is stored in observability column in each table

      CREATE TABLE ${sqr("asset_provenance_store")}(
        asset_provenance_store_id bigint GENERATED BY DEFAULT AS IDENTITY,
        context ${exqr("ltree")},
        name text NOT NULL,
        uri text NOT NULL,
        nature ${exqr("ltree")},
        meta jsonb,
        observability jsonb,
        state ${sqr("asset_state")} NOT NULL default ${sqr("asset_state_active")}(),
        created_at timestamptz NOT NULL default current_timestamp,
        created_by name NOT NULL default current_user,
        CONSTRAINT asset_provenance_store_pk UNIQUE(asset_provenance_store_id),
        CONSTRAINT asset_provenance_store_unq_row UNIQUE(context, name, uri, state)
      );
      CREATE INDEX asset_provenance_store_context_idx ON ${sqr("asset_provenance_store")} USING gist (context);
      CREATE INDEX asset_provenance_store_name_idx ON ${sqr("asset_provenance_store")} (name);
      CREATE INDEX asset_provenance_store_uri_idx ON ${sqr("asset_provenance_store")} (uri);
      CREATE INDEX asset_provenance_store_nature_idx ON ${sqr("asset_provenance_store")} USING gist (nature);
      CREATE INDEX asset_provenance_store_state_idx ON ${sqr("asset_provenance_store")} USING gist (state);
      CREATE INDEX asset_provenance_store_meta_idx ON ${sqr("asset_provenance_store")} USING gin (meta);
      CREATE INDEX asset_provenance_store_observability_idx ON ${sqr("asset_provenance_store")} USING gin (observability);
     
      -- reference to an unrevisioned asset, but not the asset itself
      CREATE TABLE ${sqr("asset_reference_store")}(
        asset_reference_store_id bigint GENERATED BY DEFAULT AS IDENTITY,
        asset_provenance_store_id bigint NOT NULL REFERENCES ${sqr("asset_provenance_store")}(asset_provenance_store_id), 
        name text NOT NULL,
        uri text NOT NULL,
        nature ${exqr("ltree")},
        meta jsonb,
        observability jsonb,
        state ${sqr("asset_state")} NOT NULL default ${sqr("asset_state_active")}(),
        created_at timestamptz NOT NULL default current_timestamp,
        created_by name NOT NULL default current_user,
        CONSTRAINT asset_reference_store_pk UNIQUE(asset_reference_store_id),
        CONSTRAINT asset_reference_store_unq_row UNIQUE(asset_provenance_store_id, name, uri, state)
      );
      CREATE INDEX asset_reference_store_id_idx ON ${sqr("asset_reference_store")} (asset_provenance_store_id);
      CREATE INDEX asset_reference_store_nature_idx ON ${sqr("asset_reference_store")} USING gist (nature);
      CREATE INDEX asset_reference_store_name_idx ON ${sqr("asset_reference_store")} (name);
      CREATE INDEX asset_reference_store_uri_idx ON ${sqr("asset_reference_store")} (uri);
      CREATE INDEX asset_reference_store_state_idx ON ${sqr("asset_reference_store")} USING gist (state);
      CREATE INDEX asset_reference_store_meta_idx ON ${sqr("asset_reference_store")} USING gin (meta);
      CREATE INDEX asset_reference_store_observability_idx ON ${sqr("asset_reference_store")} USING gin (observability);

      -- actual asset, with original untransformed (often base64 encoded) object
      CREATE TABLE ${sqr("asset_store")}(
        asset_store_id bigint GENERATED BY DEFAULT AS IDENTITY,
        asset_provenance_store_id bigint NOT NULL REFERENCES ${sqr("asset_provenance_store")}(asset_provenance_store_id),
        name text NOT NULL,
        uri text NOT NULL,
        nature ${exqr("ltree")} NOT NULL, -- physical nature of content, should be null or 'encoded.base64', 'text', 'json', 'yaml', etc.
        content_hash text NOT NULL,
        asset_revision_hash text NOT NULL,
        content text NOT NULL, -- could be base64-encoded arbitrary content or actual text, depending on nature
        content_bytes bigint NOT NULL, -- bytes in the actual content (unencoded base64 if encoded)
        content_mime_type text,
        meta jsonb,
        observability jsonb,
        state ${sqr("asset_state")} NOT NULL default ${sqr("asset_state_active")}(),
        created_at timestamptz NOT NULL default current_timestamp,
        created_by name NOT NULL default current_user,
        CONSTRAINT asset_store_pk UNIQUE(asset_store_id),
        CONSTRAINT asset_store_unq_row UNIQUE(asset_provenance_store_id, name, uri, content_hash, asset_revision_hash, state)
      );
      CREATE INDEX asset_store_provenance_id_idx ON ${sqr("asset_store")} (asset_provenance_store_id);
      CREATE INDEX asset_store_nature_idx ON ${sqr("asset_store")} USING gist (nature);
      CREATE INDEX asset_store_name_idx ON ${sqr("asset_store")} (name);
      CREATE INDEX asset_store_uri_idx ON ${sqr("asset_store")} (uri);
      CREATE INDEX asset_store_hash_idx ON ${sqr("asset_store")} (content_hash);
      CREATE INDEX asset_store_state_idx ON ${sqr("asset_store")} USING gist (state);
      CREATE INDEX asset_store_meta_idx ON ${sqr("asset_store")} USING gin (meta);
      CREATE INDEX asset_store_observability_idx ON ${sqr("asset_store")} USING gin (observability);

      -- actual asset, transformed content to text format (1:1 relationship to asset)
      CREATE TABLE ${sqr("asset_content_text_store")}(
        asset_content_text_store_id bigint GENERATED BY DEFAULT AS IDENTITY,
        asset_store_id bigint NOT NULL REFERENCES ${sqr("asset_store")}(asset_store_id), 
        content text NOT NULL,
        content_mime_type text,
        nature ${exqr("ltree")}, -- optional, logical, nature, after transformation from original asset
        observability jsonb,
        meta jsonb,
        state ${sqr("asset_state")} NOT NULL default ${sqr("asset_state_active")}(),
        created_at timestamptz NOT NULL default current_timestamp,
        created_by name NOT NULL default current_user,
        CONSTRAINT asset_content_text_pk UNIQUE(asset_content_text_store_id),
        CONSTRAINT asset_content_text_unq_row UNIQUE(asset_store_id, state)
      );      
      CREATE INDEX asset_content_text_store_asset_id_idx ON ${sqr("asset_content_text_store")} (asset_store_id);
      CREATE INDEX asset_content_text_store_nature_idx ON ${sqr("asset_content_text_store")} USING gist (nature);
      CREATE INDEX asset_content_text_store_state_idx ON ${sqr("asset_content_text_store")} USING gist (state);
      CREATE INDEX asset_content_text_store_meta_idx ON ${sqr("asset_content_text_store")} USING gin (meta);
      CREATE INDEX asset_content_text_store_observability_idx ON ${sqr("asset_content_text_store")} USING gin (observability);

      -- actual asset, transformed content to JSON format (1:1 relationship to asset)
      CREATE TABLE ${sqr("asset_content_json_store")}(
        asset_content_json_store_id bigint GENERATED BY DEFAULT AS IDENTITY,
        asset_store_id bigint NOT NULL REFERENCES ${sqr("asset_store")}(asset_store_id), 
        content jsonb NOT NULL,
        content_mime_type text,
        nature ${exqr("ltree")}, -- optional, logical, nature, after transformation from original asset
        observability jsonb,
        meta jsonb,
        state ${sqr("asset_state")} NOT NULL default ${sqr("asset_state_active")}(),
        created_at timestamptz NOT NULL default current_timestamp,
        created_by name NOT NULL default current_user,
        CONSTRAINT asset_content_json_store_pk UNIQUE(asset_content_json_store_id),
        CONSTRAINT asset_content_json_store_unq_row UNIQUE(asset_store_id, state)
      );      
      CREATE INDEX asset_content_json_store_asset_id_idx ON ${sqr("asset_content_json_store")} (asset_store_id);
      CREATE INDEX asset_content_json_store_nature_idx ON ${sqr("asset_content_json_store")} USING gist (nature);
      CREATE INDEX asset_content_json_store_state_idx ON ${sqr("asset_content_json_store")} USING gist (state);
      CREATE INDEX asset_content_json_store_meta_idx ON ${sqr("asset_content_json_store")} USING gin (meta);
      CREATE INDEX asset_content_json_store_observability_idx ON ${sqr("asset_content_json_store")} USING gin (observability);

      -- actual asset, transformed content to bytea binary representation (1:1 relationship to asset)
      CREATE TABLE ${sqr("asset_content_bytea_store")}(
        asset_content_bytea_store_id bigint GENERATED BY DEFAULT AS IDENTITY,
        asset_store_id bigint NOT NULL REFERENCES ${sqr("asset_store")}(asset_store_id), 
        content bytea NOT NULL,
        nature ${exqr("ltree")}, -- optional, logical, nature, after transformation from original asset
        content_mime_type text,
        meta jsonb,
        observability jsonb,
        state ${sqr("asset_state")} NOT NULL default ${sqr("asset_state_active")}(),
        created_at timestamptz NOT NULL default current_timestamp,
        created_by name NOT NULL default current_user,
        CONSTRAINT asset_content_bytea_store_pk UNIQUE(asset_content_bytea_store_id),
        CONSTRAINT asset_content_bytea_store_unq_row UNIQUE(asset_store_id, state)
      );      
      CREATE INDEX asset_content_bytea_store_asset_id_idx ON ${sqr("asset_content_bytea_store")} (asset_store_id);
      CREATE INDEX asset_content_bytea_store_nature_idx ON ${sqr("asset_content_bytea_store")} USING gist (nature);
      CREATE INDEX asset_content_bytea_store_state_idx ON ${sqr("asset_content_bytea_store")} USING gist (state);
      CREATE INDEX asset_content_bytea_store_meta_idx ON ${sqr("asset_content_bytea_store")} USING gin (meta);
      CREATE INDEX asset_content_bytea_store_observability_idx ON ${sqr("asset_content_bytea_store")} USING gin (observability);

      -- a document is searchable text for an asset (1:1 relationship to asset + asset_content_*)
      CREATE TABLE ${sqr("asset_content_document_store")}(
        asset_content_document_store_id bigint GENERATED BY DEFAULT AS IDENTITY,
        asset_store_id bigint NOT NULL REFERENCES ${sqr("asset_store")}(asset_store_id),
        nature ${exqr("ltree")} NOT NULL, -- should be 'asset' or 'asset.component.*', etc.
        content_text_id bigint REFERENCES ${sqr("asset_content_text_store")}(asset_content_text_store_id),
        content_json_id bigint REFERENCES ${sqr("asset_content_json_store")}(asset_content_json_store_id),
        content_bytea_id bigint REFERENCES ${sqr("asset_content_bytea_store")}(asset_content_bytea_store_id),
        content_tsv tsvector NOT NULL,
        meta jsonb,
        observability jsonb,
        state ${sqr("asset_state")} NOT NULL default ${sqr("asset_state_active")}(),
        created_at timestamptz NOT NULL default current_timestamp,
        created_by name NOT NULL default current_user,
        CONSTRAINT asset_content_document_store_content_id_chk check (content_text_id is not null or content_json_id is not null or content_bytea_id is not null),
        CONSTRAINT asset_content_document_store_pk UNIQUE(asset_content_document_store_id),
        CONSTRAINT asset_content_document_store_unq_row UNIQUE(asset_store_id, nature, state)
      );    
      CREATE INDEX asset_content_document_store_asset_id_idx ON ${sqr("asset_content_document_store")} (asset_store_id);
      CREATE INDEX asset_content_document_store_nature_idx ON ${sqr("asset_content_document_store")} USING gist (nature);
      CREATE INDEX asset_content_document_store_state_idx ON ${sqr("asset_content_document_store")} USING gist (state);
      CREATE INDEX asset_content_document_store_meta_idx ON ${sqr("asset_content_document_store")} USING gin (meta);
      CREATE INDEX asset_content_document_store_observability_idx ON ${sqr("asset_content_document_store")} USING gin (observability);

      CREATE TABLE ${sqr("asset_revision_store")}(
        asset_revision_store_id bigint GENERATED BY DEFAULT AS IDENTITY,
        asset_provenance_store_id bigint NOT NULL REFERENCES ${sqr("asset_provenance_store")}(asset_provenance_store_id),
        asset_store_id bigint NOT NULL REFERENCES ${sqr("asset_store")}(asset_store_id), 
        revision_hash text NOT NULL,
        revision_nature ${exqr("ltree")},
        revision_message text,
        author_name text,
        author_email text,
        committer_name text,
        committer_email text,
        committed_at timestamptz,
        authored_at timestamptz,
        meta jsonb,
        observability jsonb,
        state ${sqr("asset_state")} NOT NULL default ${sqr("asset_state_active")}(),
        created_at timestamptz NOT NULL default current_timestamp,
        created_by name NOT NULL default current_user,
        CONSTRAINT asset_revision_store_pk UNIQUE(asset_revision_store_id),
        CONSTRAINT asset_revision_store_unq_row UNIQUE(asset_provenance_store_id, asset_store_id, revision_hash, state)
      );
      CREATE INDEX asset_revision_store_nature_idx ON ${sqr("asset_revision_store")} USING gist (revision_nature);
      CREATE INDEX asset_revision_store_hash_idx ON ${sqr("asset_revision_store")} (revision_hash);
      CREATE INDEX asset_revision_store_state_idx ON ${sqr("asset_revision_store")} USING gist (state);
      CREATE INDEX asset_revision_store_meta_idx ON ${sqr("asset_revision_store")} USING gin (meta);
      CREATE INDEX asset_revision_store_observability_idx ON ${sqr("asset_revision_store")} USING gin (observability);
    END;
    $$ LANGUAGE PLPGSQL;

    CREATE OR REPLACE PROCEDURE ${fn.constructIdempotent(state).qName}() AS $$
    BEGIN
      ${state.setSearchPathSql()};
    END;
    $$ LANGUAGE PLPGSQL;

    CREATE OR REPLACE PROCEDURE ${fn.destroyIdempotent(state).qName}() AS $$
    BEGIN
        DROP FUNCTION IF EXISTS ${fn.unitTest(state).qName}();        
        DROP TABLE IF EXISTS ${sqr("asset_provenance_store")} CASCADE;        
        DROP TABLE IF EXISTS ${sqr("asset_reference_store")} CASCADE;        
        DROP TABLE IF EXISTS ${sqr("asset_store")} CASCADE;        
        DROP TABLE IF EXISTS ${sqr("asset_revision_store")} CASCADE;        
    END;
    $$ LANGUAGE PLPGSQL;

    CREATE OR REPLACE FUNCTION ${
    fn.unitTest(state).qName
  }() RETURNS SETOF TEXT AS $$
    BEGIN 
        RETURN NEXT has_table('${state.schema.name}', 'asset_provenance');
        RETURN NEXT has_table('${state.schema.name}', 'asset_reference');
        RETURN NEXT has_table('${state.schema.name}', 'asset');
        RETURN NEXT has_table('${state.schema.name}', 'asset_revision');
    END;
    $$ LANGUAGE plpgsql;`;
}
