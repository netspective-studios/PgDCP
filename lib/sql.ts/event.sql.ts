import * as mod from "../mod.ts";
import * as schemas from "../schemas.ts";

export function SQL(
  ctx: mod.DcpInterpolationContext,
  options?: mod.InterpolationContextStateOptions,
): mod.DcpInterpolationResult {
  const state = ctx.prepareState(
    ctx.prepareTsModuleExecution(import.meta.url),
    options || {
      schema: schemas.lifecycle,
      searchPath: [
        schemas.lifecycle.name,
        schemas.lib.name,
      ],
    },
  );
  return mod.SQL(ctx, state)`
    ${schemas.publicSchema.ltreeExtn.createSql(state)};
    CREATE OR REPLACE FUNCTION event_manager_sql(schemaName text, eventMgrName text, defaultCtx text) RETURNS text AS $$
    BEGIN
        -- changed "stream_name" to "provenance"
        -- changed "type" to "nature"

        return format($execBody$
            SET search_path TO ${
    ["%1$s", ...schemas.publicSchema.ltreeExtn.searchPath].join(", ")
  };

            CREATE TABLE IF NOT EXISTS %1$s.%2$s_store (
                id UUID NOT NULL DEFAULT gen_random_uuid() PRIMARY KEY,
                context ltree NOT NULL DEFAULT '%3$s', -- could be tenant, account, or any other "ownership" context
                nature ltree NOT NULL, -- the type, kind, or nature of the event, depends on context
                provenance ltree NOT NULL, -- the stream or human identity of the event source, depends on context and nature
                data jsonb, -- elaboration of the event
                meta_data jsonb, -- elaboration of the context, nature, provanance or other meta data
                created_at TIMESTAMP WITHOUT TIME ZONE DEFAULT (now() AT TIME ZONE 'utc') NOT NULL
            );
            CREATE INDEX %2$s_nature_idx ON %1$s.%2$s_store USING gist (nature);
            CREATE INDEX %2$s_context_idx ON %1$s.%2$s_store USING gist (context);
            CREATE INDEX %2$s_provenance_idx ON %1$s.%2$s_store USING gist (provenance);

            -- https://identity.foundation/confidential-storage/
            CREATE TABLE %1$s.%2$s_sensitivity(
                id bigint GENERATED BY DEFAULT AS IDENTITY,
                %2$s_id UUID NOT NULL REFERENCES %1$s.%2$s_store (id),
                sensitivity ltree NOT NULL,
                created_at TIMESTAMP WITHOUT TIME ZONE DEFAULT (now() AT TIME ZONE 'utc') NOT NULL,
                deactivated_at timestamp with time zone,
                updated_at timestamp with time zone,
                deleted_at timestamp with time zone
            );
            CREATE INDEX %2$s_sensitivity_idx ON %1$s.%2$s_sensitivity USING gist (sensitivity);

            -- if events need to be aliased (for denormalization or other purposes)
            CREATE TABLE %1$s.%2$s_alias(
                id bigint GENERATED BY DEFAULT AS IDENTITY,
                %2$s_id UUID NOT NULL REFERENCES %1$s.%2$s_store (id),
                alias TEXT NOT NULL,
                aliasl ltree, -- the lookup tree for the alias, if necessary
                created_at TIMESTAMP WITHOUT TIME ZONE DEFAULT (now() AT TIME ZONE 'utc') NOT NULL,
                deactivated_at timestamp with time zone,
                updated_at timestamp with time zone,
                deleted_at timestamp with time zone
            );
            CREATE INDEX %2$s_alias_idx ON %1$s.%2$s_alias (alias);
            CREATE INDEX %2$s_aliasl_idx ON %1$s.%2$s_alias USING gist (aliasl);

            -- the event is stored in %1$s.%2$s_store but accessed through %1$s.%2$s
            CREATE OR REPLACE VIEW %1$s.%2$s AS 
            SELECT * FROM %1$s.%2$s_store;

            create or replace function %1$s.event_manager_insert_%2$s() returns trigger as $genBody$
            declare
                %2$sId UUID;
            begin
                insert into %1$s.%2$s_store (context, nature, provenance, data, meta_data) select 
                    NEW.context,
                    NEW.nature,
                    NEW.provenance,
                    NEW.data,
                    NEW.meta_data
                    returning id into %2$sId;
                -- TODO: add any other inserts necessary
                -- insert into %1$s.%2$s_sensitivity (%2$s_id, value) select %2$sId, NEW.value;
                return NEW;
            end;
            $genBody$ language plpgsql;
            
            create trigger event_manager_insert_%2$s_trigger
            instead of insert on %1$s.%2$s
            for each row execute function %1$s.event_manager_insert_%2$s();

            CREATE OR REPLACE PROCEDURE ${
    schemas.lifecycle.qualifiedReference(
      "event_manager_%1$s_%2$s_destroy_all_objects",
    )
  }() AS $genBody$
            BEGIN
                EXECUTE('drop view if exists %1$s.%2$s cascade');
                EXECUTE('drop function if exists %1$s.event_manager_insert_%2$s');
                EXECUTE('drop table if exists %1$s.%2$s_alias cascade');
                EXECUTE('drop table if exists %1$s.%2$s_sensitivity cascade');
                EXECUTE('drop table if exists %1$s.%2$s cascade');
            END;
            $genBody$ LANGUAGE PLPGSQL;
        $execBody$, schemaName, eventMgrName, defaultCtx);
    END;
    $$ LANGUAGE PLPGSQL;
    CREATE OR REPLACE PROCEDURE event_manager_construct(schemaName text, eventMgrName text, defaultCtx text) AS $$
    BEGIN
        -- TODO: register execution in DCP Lifecyle log table
        EXECUTE(event_manager_sql(schemaName, eventMgrName, defaultCtx));
    END;
    $$ LANGUAGE PLPGSQL;`;
}
