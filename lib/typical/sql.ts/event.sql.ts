import * as SQLa from "../../mod.ts";
import { schemas } from "../mod.ts";

export function SQL(
  ctx: SQLa.DcpInterpolationContext,
  options?: SQLa.InterpolationContextStateOptions,
): SQLa.DcpInterpolationResult {
  const state = ctx.prepareState(
    ctx.prepareTsModuleExecution(import.meta.url),
    options || {
      schema: schemas.lifecycle,
      searchPath: [
        schemas.lifecycle,
        schemas.lib,
      ],
      extensions: [
        schemas.extensions.ltreeExtn,
        schemas.extensions.semverExtn,
      ],
    },
  );

  // deno-fmt-ignore
  return SQLa.SQL(ctx, state)`
    CREATE OR REPLACE FUNCTION event_manager_sql(schemaName text, eventTableName text, eventColName text, defaultCtx text) RETURNS text AS $$
    BEGIN
        return format($execBody$
            ${state.setSearchPathSql("%1$s")};

            CREATE TABLE IF NOT EXISTS %1$s.%2$s_store (
                id UUID NOT NULL DEFAULT gen_random_uuid() PRIMARY KEY,
                nature ltree NOT NULL, -- the type, kind, or nature of the event, depends on context
                context ltree default '%4$s', -- could be tenant, account, or any other "ownership" context
                provenance ltree NOT NULL, -- the stream or human identity of the event source, depends on context and nature
                caption text, -- a human-friendly message associated with the event
                %3$s jsonb, -- elaboration of the event
                meta_data jsonb, -- elaboration of the context, nature, provanance or other meta data
                aliases ltree[], -- symlinks
                versions semver[], -- version meta data
                created_at TIMESTAMP WITHOUT TIME ZONE DEFAULT (now() AT TIME ZONE 'utc') NOT NULL,
                created_by name NOT NULL default current_user
            );
            CREATE INDEX IF NOT EXISTS %2$s_nature_idx ON %1$s.%2$s_store USING gist (nature);
            CREATE INDEX IF NOT EXISTS %2$s_context_idx ON %1$s.%2$s_store USING gist (context);
            CREATE INDEX IF NOT EXISTS %2$s_provenance_idx ON %1$s.%2$s_store USING gist (provenance);
            CREATE INDEX IF NOT EXISTS %2$s_aliases_idx ON %1$s.%2$s_store USING gin (aliases);

            -- TODO: https://identity.foundation/confidential-storage/
            CREATE TABLE IF NOT EXISTS %1$s.%2$s_sensitivity(
                id bigint GENERATED BY DEFAULT AS IDENTITY,
                %2$s_id UUID NOT NULL REFERENCES %1$s.%2$s_store (id),
                sensitivity ltree NOT NULL,
                created_at TIMESTAMP WITHOUT TIME ZONE DEFAULT (now() AT TIME ZONE 'utc') NOT NULL,
                deactivated_at timestamp with time zone,
                updated_at timestamp with time zone,
                deleted_at timestamp with time zone
            );
            CREATE INDEX IF NOT EXISTS %2$s_sensitivity_idx ON %1$s.%2$s_sensitivity USING gist (sensitivity);

            -- the event is stored in %1$s.%2$s_store but accessed through %1$s.%2$s
            CREATE OR REPLACE VIEW %1$s.%2$s AS 
            SELECT * 
              FROM %1$s.%2$s_store
            ORDER BY created_at desc;

            create or replace function %1$s.event_manager_insert_%2$s() returns trigger as $genBody$
            declare
                %2$sId UUID;
            begin
                insert into %1$s.%2$s_store (context, nature, provenance, caption, %3$s, meta_data, aliases, versions) select 
                    (CASE WHEN (NEW.context IS NULL) THEN '%4$s' ELSE NEW.context END),
                    NEW.nature,
                    NEW.provenance,
                    NEW.caption,
                    NEW.%3$s,
                    NEW.meta_data,
                    NEW.aliases,
                    NEW.versions
                    returning id into %2$sId;
                -- TODO: add any other inserts necessary
                -- insert into %1$s.%2$s_sensitivity (%2$s_id, value) select %2$sId, NEW.value;
                return NEW;
            end;
            $genBody$ language plpgsql;
            
            create trigger event_manager_insert_%2$s_trigger
            instead of insert on %1$s.%2$s
            for each row execute function %1$s.event_manager_insert_%2$s();

            CREATE OR REPLACE PROCEDURE ${schemas.lifecycle.qualifiedReference("event_manager_%1$s_%2$s_destroy_all_objects")}() AS $genBody$
            BEGIN
                EXECUTE('drop view if exists %1$s.%2$s cascade');
                EXECUTE('drop function if exists %1$s.event_manager_insert_%2$s');
                EXECUTE('drop table if exists %1$s.%2$s_sensitivity cascade');
                EXECUTE('drop table if exists %1$s.%2$s cascade');
            END;
            $genBody$ LANGUAGE PLPGSQL;
        $execBody$, schemaName, eventTableName, eventColName, defaultCtx);
    END;
    $$ LANGUAGE PLPGSQL;
    CREATE OR REPLACE PROCEDURE event_manager_construct(schemaName text, eventTableName text, eventColName text, defaultCtx text) AS $$
    BEGIN
        -- TODO: register execution in DCP Lifecyle log table
        EXECUTE(event_manager_sql(schemaName, eventTableName, eventColName, defaultCtx));
    END;
    $$ LANGUAGE PLPGSQL;`;
}
