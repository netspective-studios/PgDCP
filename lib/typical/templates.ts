import { textWhitespace as tw } from "../deps.ts";
import * as SQLa from "../sqla.ts";
import * as schemas from "./schemas.ts";

export const preface: SQLa.DcpTemplateSupplier = (state) => {
  const { provenance } = state.ie;
  // deno-fmt-ignore
  return tw.unindentWhitespace(`
      -- Code generated by PgDCP ${state.ic.engine.version}. DO NOT EDIT.  
      -- source: ${provenance.identity} (${provenance.humanReadableSource(provenance)})
      -- version: ${provenance.version}`);
};

export const embeddedPreface: SQLa.DcpTemplateSupplier = (state) => {
  const { provenance } = state.ie;
  // deno-fmt-ignore
  return tw.unindentWhitespace(`
      -- embedded from: ${provenance.identity} (${provenance.humanReadableSource(provenance)})
      -- version: ${provenance.version}`);
};

export const schema: SQLa.DcpTemplateSupplier = (state) => {
  return `${state.schema.createSchemaSql(state)};`;
};

export const extensions: SQLa.DcpTemplateSupplier = (state) => {
  if (state.extensions) {
    return [
      schemas.extensions.createSchemaSql(state) + ";",
      ...(state.extensions.map((e) => `${e.createSql(state)};`)),
    ].join("\n");
  }
  return "-- no extensions required";
};

export const searchPath: SQLa.DcpTemplateSupplier = (state) => {
  return state.searchPath
    ? `SET search_path TO ${
      [...new Set(state.searchPath.map((s) => s.name))].join(", ")
    };` // only unique schemas in search path
    : `SET search_path TO ${schemas.experimental}; -- ${schemas.experimental} is used because no searchPath provided`;
};
